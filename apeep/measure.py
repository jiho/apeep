import logging
import os

import skimage.measure
import numpy as np
import hashlib
import pandas as pd

import apeep.timers as t
# import apeep.im_pillow as im
import apeep.im_opencv as im
# TODO homogenise the image saving with the rest

# from ipdb import set_trace as db

@t.timer
def measure(img, img_labelled, props=['area']):
    """
    Measure particles
    
    Args:
        img (ndarray): image (of type float)
        img_labelled (ndarray): labelled image (mask with each particle 
            numbered as an integer)
        properties (list): list of properties to extract from each particle
    
    Returns:
        particles (dict): dict of ndarrays containing particles; the keys are
            their md5 checksum
        partitles_props (dict): dict of arrays/lists containing their
            properties, suitable to be turned into a pandas DataFrame
    """

    # get general logger
    log = logging.getLogger()

    # initiate particle measurements
    regions = skimage.measure.regionprops(label_image=img_labelled, intensity_image=img)
    
    # extract the content of the particles
    particles = [get_particle_array(r) for r in regions]
    # uniquement identify particles with their md5 checksum
    particles = {hashlib.md5(p).hexdigest():p for p in particles}
    
    log.debug("{} particles".format(len(particles)))
    # TODO add padding
    # TODO add scale bar

    # store this as their first property
    particle_props = {'object_id': list(particles.keys())}    
    # append the other properties we need
    # NB: append so that the md5 column is the first one
    particle_props.update(skimage.measure._regionprops._props_to_dict(regions, properties=props))
    # alternative to using this private method
    # particle_props.update(measure.regionprops_table(
    #     label_image=img_labelled,
    #     intensity_image=img,
    #     properties=props
    # ))
    
    return (particles, particle_props)

def get_particle_array(x):
    """
    Extract the particle pixels and blank out the outside
    
    Args:
        x (RegionProperties): from skimage.measure.region_props
    
    Returns:
        (ndarray) of floats containing the particle values
    """
    # extract the particle region
    particle = x._intensity_image[x._slice] * 0.997
    # mask the outside of the particle with white
    particle = np.where(x._label_image[x._slice] != 0, particle, 1.)
    return(particle)


@t.timer
def write_particles_props(particles_props, destination):
    """
    Write a set of particles to disk
    
    Args:
        particles_props (dict): dictionnary of particles properties
            generated by apeep.measure
        destination (str): path to the directory where *particles* are
            (i.e. has the subdirectory below "particles")
    
    Returns:
        Nothing
    """

    # split the destination directory
    base_dir = os.path.dirname(destination)
    sub_dir = os.path.basename(destination)

    # convert to pandas DataFrame
    particles_props = pd.DataFrame(particles_props)
    
    # for EcoTaxa:
    # compute image file name
    particles_props['img_file_name'] = sub_dir + "/" + particles_props['object_id'] + ".png"
        
    # write to file
    particles_file = os.path.join(base_dir, "ecotaxa_particles.tsv.gz")
    if not os.path.exists(particles_file):
        # initialise, with headers
        particles_props.to_csv(particles_file,
            index=False, sep="\t", header=True)
    else:
        # just append to the file
        with open(particles_file, "a") as outfile:
            particles_props.to_csv(outfile,
                index=False, sep="\t", header=False)
    pass

@t.timer
def write_particles(particles, destination):
    """
    Write a set of particles to disk
    
    Args:
        particles (dict): dictionnary of particles generated by apeep.measure
        destination (str): path to the destination directory
    
    Returns:
        Nothing
    """
    for name,part in particles.items():
        im._save(part, os.path.join(destination, name + ".png"))
    pass
